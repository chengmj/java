## java基础
### HelloWorld
- java是区分大小写的
- 类名与文件名要一致，如下示例文件名必须为HelloWorld.java
```java
public class HelloWorld {
    public static void main(String[] args){
        System.out.println("Hello World!");
        System.out.println(5+6);
    }
}
```

### java中的字符集
- java中用的是UTF-16编码的Unicode。
- UTF-16用16个bit，即两个byte，这也是char占用两个byte的原因。当把char转成数字的时候，需要用int。
- String不是java中的保留字。

```java
public class HelloWorld {
    public static void main(String[] args){
        System.out.println("Hello World!");
        double a = 99;
        int b = 5;
        System.out.println(a/b);
        System.out.println("a + b =" + a + b);   //此处考虑算术运算优先级，+ 为字符串拼接
        System.out.println("a + b =" + (a + b));
        System.out.println("a\tb\n\\n");
        char d = '\u81e7';
        System.out.println(d);
        System.out.println(1==1);
        System.out.println(a < b);
    }
}

```
输出结果：    
```
Hello World!
19.8
a + b =99.05
a + b =104.0
a	b
\n
臧
true
false

```
## java class
java中不能有重复的类。

### package
为了便于管理类，可以将类放在文件夹里，这时就需要用package语句来告诉Java这个类放在了哪个package里。
- package语句要和源文件的目录完全对应，大小写要一致。
- package读作包，一般来说，类都会在包里，不会直接放在根目录。
- 不同包里可以有相同名字的类。
- 一个类只能有一个package语句，如果有package语句，必须是类的第一行有效代码。

### import
- 当使用另一个包里的类时，需要带上包名。
- 每次都使用包名很繁琐，可以在使用的类上面用import语句。
- import语句可以有多个。
- 如果需要import一个包中的多个类，可以使用*通配符。

### public
- 被public修饰的属性，可以被任意包中的类访问。
- 没有访问修饰符的属性，称作缺省的访问修饰符，可以被本包内的其他类和自己的对象访问。
- 访问修饰符是一种限制或者允许属性访问的修饰符。

### 类的全限定名
- 包名 + 类名 = 类的全限定名。也可以简称为类的全名。
- 同一个Java程序中全限定名不可重复。

### 方法
- 类通过成员变量和方法来描述世界，成员变量描述一类事物的属性，是数据。方法是描述一类事物的行为和功能，是对数据的操作。
- 方法中的代码可以通过操作一个对象的成员变量来完成一个功能。
- 方法是Java中代码执行的单元，是代码的载体。所有的代码，都必须属于某一个方法。
- 方法不是对象的一部分，属于某一个类。

### this
- this关键字代表本类对象的引用。
- this除了可以调用成员变量或成员方法之外，还可以作为方法的返回值。如`return this;`，将类的对象返回。
- this还可以调用构造方法。如：

```java
public class anyThing {
    public anyThing(){
        this("this 调用有参构造方法");
        System.out.println("无参构造方法");
    }
    public anyThing(String name){
        System.out.println("有参构造方法" + name);
    }
}
```


### 类的构造方法
- 构造方法是一个与类同名的方法。
- 对象的创建就是通过构造方法创建的。
- 当类实例化一个对象时，会自动调用构造方法。
- 构造方法没有返回值。
- 当类中没有明确定义构造方法时，编译器会自动创建一个不带参数的默认构造方法。

### 静态变量、常量和方法
- static关键字。
- 静态成员属于类所有，可以在本类或其他类中使用类名加“.”运算符调用静态成员。
- 静态方法中不可以使用this关键字。
- 在静态方法中不可以直接调用非静态方法。
- 不能将方法体内的局部变量声明为static。

### 对象的比较
- == 和 equals()方法。
- == 比较的是两个对象引用的地址是否相同。
- equals()是String类中的方法，比较的是两个对象引用所指的内容是否相等。

示例代码：
```java
public class ExampleCompare {
    public static void main(String[] args) {
        String c1 = new String("abc");
        String c2 = new String("abc");
        String c3 = c1;
        System.out.println("c1 == c3 的运算结果为：" + (c1 == c3));
        System.out.println("c2 == c3 的运算结果为：" + (c2 == c3));
        System.out.println("c1.equals(c2) 的运算结果为：" + c1.equals(c2));
        System.out.println("c2.equals(c3) 的运算结果为：" + c2.equals(c3));

    }
}
```
运行结果：
```java
c1 == c3 的运算结果为：true
c2 == c3 的运算结果为：false
c1.equals(c2) 的运算结果为：true
c2.equals(c3) 的运算结果为：true
```

### java继承
- 通过 extends 关键字可以申明一个类是从另外一个类继承而来的，如：

```java
class 父类 {
}
 
class 子类 extends 父类 {
}
```

- java继承类型
![Java继承类型](java-images/types_of_inheritance.png)

- super关键字：我们可以通过super关键字来实现对父类成员的访问，用来引用当前对象的父类。
- final 关键字声明类可以把类定义为不能继承的，即最终类；或者用于修饰方法，该方法不能被子类重写
==注:实例变量也可以被定义为 final，被定义为 final 的变量不能被修改。被声明为 final 类的方法自动地声明为 final，但是实例变量并不是 final==
- 构造器，子类是不继承父类的构造器（构造方法或者构造函数）的，它只是调用（隐式或显式）。如果父类的构造器带有参数，则必须在子类的构造器中显式地通过 `super` 关键字调用父类的构造器并配以适当的参数列表。
如果父类构造器没有参数，则在子类的构造器中不需要使用 super 关键字调用父类构造器，系统会自动调用父类的无参构造器。

### Java重写(Override)
- 参数列表必须完全与被重写方法的相同；
- 返回类型与被重写方法的返回类型可以不相同，但是必须是父类返回值的派生类（java5 及更早版本返回类型要一样，java7 及更高版本可以不同）；
- 访问权限不能比父类中被重写的方法的访问权限更低。例如：如果父类的一个方法被声明为public，那么在子类中重写该方法就不能声明为protected。
- 父类的成员方法只能被它的子类重写。
- 声明为final的方法不能被重写。
- 声明为static的方法不能被重写，但是能够被再次声明。
- 子类和父类在同一个包中，那么子类可以重写父类所有方法，除了声明为private和final的方法。
- 子类和父类不在同一个包中，那么子类只能够重写父类的声明为public和protected的非final方法。
- 重写的方法能够抛出任何非强制异常，无论被重写的方法是否抛出异常。但是，重写的方法不能抛出新的强制性异常，或者比被重写方法声明的更广泛的强制性异常，反之则可以。
- 构造方法不能被重写。
- 如果不能继承一个方法，则不能重写这个方法。


### Java重载(Overload)
重载(overloading) 是在一个类里面，方法名字相同，而参数不同。返回类型可以相同也可以不同。
每个重载的方法（或者构造函数）都必须有一个独一无二的参数类型列表。

- 被重载的方法必须改变参数列表(参数个数或类型不一样)；
- 被重载的方法可以改变返回类型；
- 被重载的方法可以改变访问修饰符；
- 被重载的方法可以声明新的或更广的检查异常；
- 方法能够在同一个类中或者在一个子类中被重载。
- 无法以返回值类型作为重载函数的区分标准。

### Java多态
多态是同一个行为具有多个不同表现形式或形态的能力。多态就是同一个接口，使用不同的实例而执行不同操作。

#### 多态的实现方式
- 重写
- 接口
- 抽象类和抽象方法

### 虚函数
Java 中其实没有虚函数的概念，它的普通函数就相当于 C++ 的虚函数，动态绑定是Java的默认行为。如果 Java 中不希望某个函数具有虚函数特性，可以加上 final 关键字变成非虚函数。

### Java抽象类
在面向对象的概念中，所有的对象都是通过类来描绘的，但是反过来，并不是所有的类都是用来描绘对象的，如果一个类中没有包含足够的信息来描绘一个具体的对象，这样的类就是抽象类。
抽象类除了不能实例化对象之外，类的其它功能依然存在，成员变量、成员方法和构造方法的访问方式和普通类一样。

由于抽象类不能实例化对象，所以抽象类必须被继承，才能被使用。也是因为这个原因，通常在设计阶段决定要不要设计抽象类。
父类包含了子类集合的常见的方法，但是由于父类本身是抽象的，所以不能使用这些方法。
在Java中抽象类表示的是一种继承关系，一个类只能继承一个抽象类，而一个类却可以实现多个接口。
- 在Java语言中使用`abstract class`来定义抽象类

#### 继承抽象类
可以通过一般的方法继承抽象类。

#### 抽象方法
抽象方法没有定义，方法名后面直接跟一个分号，而不是花括号。如：
`public abstract double computePay();`
- 如果一个类包含抽象方法，那么该类必须是抽象类。
- 任何子类必须重写父类的抽象方法，或者声明自身为抽象类。
- 继承抽象方法的子类必须重写该方法。否则，该子类也必须声明为抽象类。最终，必须有子类实现该抽象方法，否则，从最初的父类到最终的子类都不能用来实例化对象。

#### 抽象类总结规定
1. 抽象类不能被实例化(初学者很容易犯的错)，如果被实例化，就会报错，编译无法通过。只有抽象类的非抽象子类可以创建对象。
2. 抽象类中不一定包含抽象方法，但是有抽象方法的类必定是抽象类。
3. 抽象类中的抽象方法只是声明，不包含方法体，就是不给出方法的具体实现也就是方法的具体功能。
4. 构造方法，类方法（用 static 修饰的方法）不能声明为抽象方法。
5. 抽象类的子类必须给出抽象类中的抽象方法的具体实现，除非该子类也是抽象类。

### Java接口
接口（英文：Interface），在JAVA编程语言中是一个抽象类型，是抽象方法的集合，接口通常以	`interface`来声明。一个类通过继承接口的方式，从而来继承接口的抽象方法。
接口并不是类，编写接口的方式和类很相似，但是它们属于不同的概念。类描述对象的属性和方法。接口则包含类要实现的方法。
除非实现接口的类是抽象类，否则该类要定义接口中的所有方法。

接口无法被实例化，但是可以被实现。一个实现接口的类，必须实现接口内所描述的所有方法，否则就必须声明为抽象类。另外，在 Java 中，接口类型可用来声明一个变量，他们可以成为一个空指针，或是被绑定在一个以此接口实现的对象。

#### 接口与类的相似点
- 一个接口可以有多个方法。
- 接口文件保存在 .java 结尾的文件中，文件名使用接口名。
- 接口的字节码文件保存在 .class 结尾的文件中。
- 接口相应的字节码文件必须在与包名称相匹配的目录结构中。

#### 接口与类的区别
- 接口不能用于实例化对象。
- 接口没有构造方法。
- 接口中所有的方法必须是抽象方法。
- 接口不能包含成员变量，除了 static 和 final 变量。
- 接口不是被类继承了，而是要被类实现。
- 接口支持多继承。		

#### 抽象类和接口的区别
- 抽象类中的方法可以有方法体，就是能实现方法的具体功能，但是接口中的方法不行。
- 抽象类中的成员变量可以是各种类型的，而接口中的成员变量只能是 public static final 类型的。
- 接口中不能含有静态代码块以及静态方法(用 static 修饰的方法)，而抽象类是可以有静态代码块和静态方法。
- 一个类只能继承一个抽象类，而一个类却可以实现多个接口。

#### 接口的声明
语法格式如下：
```java
[可见度] interface 接口名称 [extends 其他的接口名] {
        // 声明变量
        // 抽象方法
}
```

#### 接口的实现
类使用implements关键字实现接口。在类声明中，Implements关键字放在class声明后面。
如：
`public class MammalInt implements Animal{...}`

重写接口中声明的方法时，需要注意以下规则：
- 类在实现接口的方法时，不能抛出强制性异常，只能在接口中，或者继承接口的抽象类中抛出该强制性异常。
- 类在重写方法时要保持一致的方法名，并且应该保持相同或者相兼容的返回值类型。
- 如果实现接口的类是抽象类，那么就没必要实现该接口的方法。 

在实现接口的时候，也要注意一些规则：
- 一个类可以同时实现多个接口。
- 一个类只能继承一个类，但是能实现多个接口。
- 一个接口能继承另一个接口，这和类之间的继承比较相似。

#### 接口的继承
一个接口能继承另一个接口，和类之间的继承方式比较相似。接口的继承使用extends关键字，子接口继承父接口的方法。如：Sports接口被Football接口继承
`public interface Football extends Sports`


#### 接口的多继承
接口允许多继承，在接口的多继承中extends关键字只需要使用一次，在其后跟着继承接口，如：
`public interface Hockey extends Sports, Event`

#### 标记接口
没有任何方法的接口被称为标记接口。标记接口主要用于以下两种目的：
- 建立一个公共的父接口：
正如EventListener接口，这是由几十个其他接口扩展的Java API，你可以使用一个标记接口来建立一组接口的父接口。例如：当一个接口继承了EventListener接口，Java虚拟机(JVM)就知道该接口将要被用于一个事件的代理方案。

- 向一个类添加数据类型：
这种情况是标记接口最初的目的，实现标记接口的类不需要定义任何接口方法(因为标记接口根本就没有方法)，但是该类通过多态性变成一个接口类型
